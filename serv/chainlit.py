from langchain import PromptTemplate, OpenAI, LLMChain
from dotenv import load_dotenv
import chainlit as cl
import os
import openai
from langchain.embeddings.openai import OpenAIEmbeddings
from langchain.text_splitter import CharacterTextSplitter
from langchain.vectorstores import FAISS
from langchain.chat_models import ChatOpenAI
from langchain.chains.question_answering import load_qa_chain
from langchain.document_loaders import DirectoryLoader
from langchain.document_loaders.csv_loader import CSVLoader
import pandas as pd
import numpy as np
load_dotenv()

openai_api_key=os.getenv('OPENAI_API_KEY')
template = """You are business assistant, generate answers relevant to the dataset provided to you. Utilize the information available in the dataset. If the information is not present in the dataset, respond with 'This information is not available in the dataset.' along with the expected data.
    {context}
    Persona Table:

Cust_ID: This is a unique customer identifier. It associates the persona data with a specific customer.

Location_Type: This column represents the type of location where the customer is based. It can be used to categorize customers based on their geographic location, which might be relevant for marketing or product targeting.

Investment_risk_tol: This attribute reflects the customer's tolerance for investment risk. It can help identify customers who are more risk-averse or risk-tolerant, which is crucial for offering suitable investment products and advice.

Avg_mon_expense: This column indicates the average monthly expenses of the customer. It's essential for understanding the customer's spending habits and financial capacity.

Investment_needs: This attribute describes the customer's specific investment needs or preferences. For instance, it could indicate whether the customer is interested in long-term investments, short-term gains, or specific asset classes.

Banking_Needs: This column captures the customer's banking needs, which may include services like savings accounts, loans, or specialized financial products. It helps in tailoring banking services to individual customer requirements.

Pref_channel: Preferred communication channel refers to the customer's choice of how they prefer to be contacted by the bank or financial institution. This could include options like email, phone, in-person meetings, or mobile app notifications.

Lifestyle: The lifestyle attribute provides insights into the customer's lifestyle choices and preferences. It might encompass factors such as spending on leisure, travel, or other discretionary expenses.

Net_Worth: This attribute represents the customer's net worth, which is the difference between their assets and liabilities. It's a key indicator of financial stability and wealth.

Persona: The persona column categorizes the customer into specific segments or personas based on their financial behavior and preferences. These personas can include categories like "conservative investor," "high-net-worth individual," or "millennial saver."

Biz_Type: If applicable, this attribute specifies the type of business the customer is involved in. It's particularly relevant if the customer is a business owner or entrepreneur.

Biz_Size: Indicates the size of the customer's business. It can be small, medium, or large, depending on the scale of the customer's entrepreneurial activities.

Biz_Age: Represents the age of the customer's business. It's useful for understanding whether the business is a startup or an established enterprise.

Turnover: This attribute reflects the annual turnover or revenue generated by the customer's business. It's a key metric for assessing the financial health of business customers.

Credit_Score: The credit score of the customer is an important indicator of their creditworthiness. It's crucial for making lending decisions and determining the terms of loans or credit lines.


RM_KRAs Table:

Employee_ID: This is a unique identifier for each employee (relationship manager). It can be used to identify a specific RM in queries.

TARGET: This column represents the name of the target associated with the Key Result Areas (KRAs) for each RM. The model can use this to understand what specific objectives or goals the RM is working towards.

Unit: This field indicates the unit of measurement for the target. For instance, it could be in terms of revenue, customer acquisitions, or any other relevant metric.

Target_FY22_23_ABS: This column provides the target assigned to the employee in absolute values for the fiscal year 2022-23. The model can use this to understand the quantifiable goal set for the RM.

Target_FY22_23_PCT: This column provides the target assigned to the employee in percentage terms for the fiscal year 2022-23. This can be useful for understanding percentage-based goals or improvements.

Various columns with month names and "_COMPLETION_ABS": These columns indicate the completion progress in absolute values for each KRA for each month. They can help the model track and report on how well an RM is progressing toward their goals on a monthly basis.

Various columns with month names and "_COMPLETION_PCT": Similar to the completion in absolute values, these columns represent the completion progress in percentage terms for each KRA for each month. This allows the model to understand the percentage achievement of KRAs over time.

contacthistory Table:

Cust_ID: Unique customer identifier. It can be used to identify the customer involved in the contact.

RM: Relationship Manager associated with the customer for a specific contact. It helps in attributing contacts to specific RMs.

contact_date: This column records the date when the customer was contacted. It enables the model to filter and analyze contacts based on specific timeframes or date ranges.

Product: Indicates the financial product associated with the contact. This helps in understanding which product or service the contact was related to.

disposition: Represents the outcome or disposition of the contact. It can be used to determine whether the contact was successful, unresolved, or had some other outcome.

Customers Table:

Cust_ID: Unique customer identifier.
Age: Customer's age (for queries related to age-based analysis).
Gender: Customer's gender (for gender-specific queries).
Location: Customer's location (for location-specific queries).
Maritial_Status: Customer's marital status (for marital status-specific queries).
Education: Customer's education level (for education-related queries).
Occupation: Customer's occupation (for occupation-specific queries).
Income: Customer's income (for income-related queries).
Dependencies: Number of dependents (for queries involving dependents).
Digital_ind: Indicator of digital presence (for digital presence-related queries).
Email: Customer's email address (for queries related to email communication).
Phone: Customer's phone number (for phone-related queries).
Address: Customer's address (for queries involving address information).
Customer_Employees Table:

Cust_ID: Unique customer identifier.
RM: Relationship Manager associated with the customer (for RM-related queries).
ACCT_BAL: Customer's account balance (for queries related to account balance).
ACCT_BAL_FY_START: Account balance at the start of the fiscal year.
Employees Table:

Emp_ID: Unique employee identifier.
Name: Employee's name.
Email: Employee's email address.
SOL_ID: Solution ID associated with the employee.
Cluster: Employee's cluster (for cluster-specific queries).
Circle: Employee's circle (for circle-specific queries).
Region: Employee's region (for region-specific queries).
Branch_Type: Type of branch associated with the employee.
Persona Table:

Cust_ID: Unique customer identifier.
Location_Type: Type of location where the customer is based.
Investment_risk_tol: Customer's risk tolerance (for risk-related queries).
Avg_mon_expense: Average monthly expenses of the customer.
Investment_needs: Customer's investment needs (for investment-related queries).
BAnking_Needs: Customer's banking needs (for banking-related queries).
Pref_channel: Preferred communication channel (for communication-related queries).
Lifestyle: Customer's lifestyle (for lifestyle-specific queries).
Net_Worth: Customer's net worth (for net worth-related queries).
Persona: Customer persona (for persona-specific queries).
Biz_Type: Type of business the customer is involved in (for business-related queries).
Biz_Size: Size of the customer's business (for business-related queries).
Biz_Age: Age of the customer's business (for business-related queries).
Turnover: Business turnover (for business-related queries).
Credit_Score: Customer's credit score (for credit-related queries).
Product_Holding Table:

Cust_ID: Unique customer identifier.
Various columns representing different financial products (e.g., Term_Deposit, Auto_Loan) to check if the customer holds these products (for product-specific queries).
RM_KRAs Table:

Employee_ID: Unique employee identifier.
TARGET: Name of the target associated with Key Result Areas (KRAs) (for KRA-related queries).
Various columns with month names and "_COMPLETION_ABS" and "_COMPLETION_PCT" indicate completion progress for each KRA for each month (for performance-related queries).
contacthistory Table:

Cust_ID: Unique customer identifier.
RM: Relationship Manager associated with the customer.
contact_date: Date of contact (for date-specific queries).
Product: Product associated with the contact (for product-specific queries).
disposition: Outcome of the contact (for disposition-related queries).
  """

path_RM = './DATA/RM_KRAs.csv'
path_c = './DATA/Customers.csv'
path_c_e = './DATA/Customers_Employees.csv'
path_persona = './DATA/Persona.csv'
path_product_holding = './DATA/Product_Holding.csv'
path_contact = './DATA/contacthistory.csv'

def predict(path_RM, path_c, path_c_e, path_persona, path_product_holding ,path_contact, template):
  RM_KRAs = pd.read_csv(path_RM)
  customers = pd.read_csv(path_c)
  customers_employees = pd.read_csv(path_c_e)
  persona = pd.read_csv(path_persona)
  product_holding = pd.read_csv(path_product_holding)
  contacthistory = pd.read_csv(path_contact)
  template = template
  prompt_template = PromptTemplate.from_template(template, input_variables = ['context'])
  customers.drop('Address', inplace=True, axis=1)
  customers_employees.rename(columns={'RM': 'Employee_ID'}, inplace=True)
  my_df1 = customers_employees.merge(customers, on='Cust_ID', how='inner')
  product_summary_df = product_holding.copy()

  product_summary_df['Product'] = product_summary_df.drop(columns=['Cust_ID']).apply(
      lambda row: ', '.join([col.replace('_', ' ') for col in row.index if row[col] == 1]), axis=1)

  product_summary_df.drop(columns=[col for col in product_summary_df.columns if col != 'Product'], inplace=True)

  product_summary_df['Product'].replace('', np.nan, inplace=True)
  product_summary_df['Cust_ID'] = product_holding['Cust_ID']

  my_df2 = my_df1.merge(product_summary_df, on='Cust_ID', how='inner')
  my_df3 = my_df2.merge(persona, on='Cust_ID', how='inner')

  my_df1_csv = my_df1.to_csv('merged.csv', index = True)

  loader = CSVLoader('/content/merged.csv', encoding="utf-8", csv_args={'delimiter': ',', 'quotechar': '"'})
  data = loader.load()

  llm = ChatOpenAI(temperature=0.7, openai_api_key = openai_api_key, model_name='gpt-3.5-turbo')
  chain = load_qa_chain(llm, chain_type="stuff", prompt=prompt_template)

  text_splitter = CharacterTextSplitter(chunk_size=1000, chunk_overlap=0)

  chunks = text_splitter.split_documents(data)

  embeddings = OpenAIEmbeddings(openai_api_key = openai_api_key)
  vector_db1 = FAISS.from_documents(chunks[:5000], embedding = embeddings)
  vector_db2 = FAISS.from_documents(chunks[5000:], embedding = embeddings)

  query = 'Tell me which employee is the best. Consider Account balance and rating.'
  docs1 = vector_db1.similarity_search(query)
  docs2= vector_db2.similarity_search(query)
  final_docs = np.concatenate([docs1, docs2], axis=0)
  return chain.run(input_documents= final_docs, question=query)

@cl.on_chat_start
def main():
    # Instantiate the chain for that user session
    # prompt = PromptTemplate(template=template)
    # llm_chain = LLMChain(prompt=prompt, llm=OpenAI(temperature=0,openai_api_key=os.getenv('OPENAI_API_KEY')), verbose=True)
    llm_chain = predict(path_RM, path_c, path_c_e, path_persona, path_product_holding, path_contact, template=template)

    # Store the chain in the user session
    cl.user_session.set("llm_chain", llm_chain)


@cl.on_message
async def main(message: str):
    # Retrieve the chain from the user session
    llm_chain = cl.user_session.get("llm_chain")  # type: LLMChain

    # Call the chain asynchronously
    res = await llm_chain.acall(message, callbacks=[cl.AsyncLangchainCallbackHandler()])

    # Do any post processing here

    # "res" is a Dict. For this chain, we get the response by reading the "text" key.
    # This varies from chain to chain, you should check which key to read.
    await cl.Message(content=res["text"]).send()


